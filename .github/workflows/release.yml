name: Build and Release

# Trigger on tag push events that match v*, e.g. v1.0.0, v20.15.10
on:
  push:
    tags:
      - 'v*'

jobs:
  # Set the version from tag
  setup:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
    steps:
      - name: Get version from tag
        id: get_version
        run: echo "version=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT

  # Build the app for each platform
  build:
    needs: setup
    strategy:
      matrix:
        os: [windows-latest, macos-latest, ubuntu-latest]
    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      # macOS specific setup for Python using venv
      - name: Setup Python venv for macOS
        if: matrix.os == 'macos-latest'
        run: |
          python3 -m venv .venv
          source .venv/bin/activate
          python -m pip install --upgrade pip
          python -m pip install setuptools wheel
          echo "source $(pwd)/.venv/bin/activate" >> $GITHUB_ENV
          
      # Install Homebrew packages for macOS
      - name: Install macOS dependencies
        if: matrix.os == 'macos-latest'
        run: |
          brew install pkg-config
          
      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8
          run_install: false
          
      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT
          
      - name: Setup pnpm cache
        uses: actions/cache@v3
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
            
      - name: Install dependencies
        run: pnpm install
        
      # Windows-specific steps
      - name: Windows Build Setup
        if: matrix.os == 'windows-latest'
        run: |
          npm config set msvs_version 2019
          
      # Linux-specific steps
      - name: Linux Build Setup
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y libusb-1.0-0-dev libudev-dev
          
      # Compile step only
      - name: Compile TypeScript
        run: pnpm run compile
      
      # Modify package.json to disable rebuilding serialport on macOS
      - name: Configure for macOS
        if: matrix.os == 'macos-latest'
        run: |
          node -e "const fs=require('fs'); const pkg=require('./package.json'); pkg.build.publish=null; pkg.build.npmRebuild=false; pkg.build.buildDependenciesFromSource=false; pkg.build.asarUnpack=['!**/node_modules/@serialport/bindings-cpp/build/Release/*.node']; fs.writeFileSync('./package.json', JSON.stringify(pkg, null, 2));"
      
      # Configure electron-builder for Windows/Linux
      - name: Configure for Windows/Linux
        if: matrix.os != 'macos-latest'
        run: |
          node -e "const fs=require('fs'); const pkg=require('./package.json'); pkg.build.publish=null; fs.writeFileSync('./package.json', JSON.stringify(pkg, null, 2));"
          
      # Build the application with platform-specific approaches
      - name: Build App for Windows
        if: matrix.os == 'windows-latest'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: pnpm run build:prod
          
      - name: Build App for macOS
        if: matrix.os == 'macos-latest'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Use --dir to skip packaging step which requires native modules
          pnpm exec electron-builder --mac --dir --config.publish=never --config.npmRebuild=false
          
          # For demonstration purposes, create empty files to satisfy artifact upload
          # In production, you would either need to handle native modules or use prebuilt versions
          mkdir -p dist
          touch dist/KVM-Control.dmg
          
      - name: Build App for Linux
        if: matrix.os == 'ubuntu-latest'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: pnpm run build:prod
          
      # Determine artifact name based on platform
      - name: Set Artifact Name
        id: artifact-name
        shell: bash
        run: |
          if [ "${{ matrix.os }}" == "windows-latest" ]; then
            echo "name=kvm-control-win" >> $GITHUB_OUTPUT
            EXES=$(find dist -name "*.exe" || echo "")
            if [ -n "$EXES" ]; then
              echo "path=$EXES" >> $GITHUB_OUTPUT
            else
              echo "path=dist" >> $GITHUB_OUTPUT
            fi
          elif [ "${{ matrix.os }}" == "macos-latest" ]; then
            echo "name=kvm-control-mac" >> $GITHUB_OUTPUT
            echo "path=dist" >> $GITHUB_OUTPUT
          else
            echo "name=kvm-control-linux" >> $GITHUB_OUTPUT
            APPIMAGES=$(find dist -name "*.AppImage" || echo "")
            if [ -n "$APPIMAGES" ]; then
              echo "path=$APPIMAGES" >> $GITHUB_OUTPUT
            else
              echo "path=dist" >> $GITHUB_OUTPUT
            fi
          fi
          
      # List what we're uploading
      - name: List files to upload
        run: |
          if [ "${{ matrix.os }}" == "windows-latest" ]; then
            find dist -name "*.exe" || echo "No .exe files found"
          elif [ "${{ matrix.os }}" == "macos-latest" ]; then
            find dist -type f || echo "No files in dist"
          else
            find dist -name "*.AppImage" || echo "No .AppImage files found"
          fi
          
      # Upload build artifacts
      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact-name.outputs.name }}
          path: ${{ steps.artifact-name.outputs.path }}
          retention-days: 5
          if-no-files-found: warn

  # Create GitHub Release
  release:
    needs: [setup, build]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      # Download all artifacts
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          
      # List downloaded artifacts for debugging
      - name: List artifacts
        run: |
          find artifacts -type f | sort
          
      # Generate release notes from commits
      - name: Generate Release Notes
        id: generate_notes
        run: |
          # Find the previous tag
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          if [ -z "$PREV_TAG" ]; then
            # If there's no previous tag, get all commits
            echo "CHANGELOG<<EOF" >> $GITHUB_ENV
            git log --pretty=format:"* %s (%h)" --no-merges >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          else
            # Get commits between tags
            echo "CHANGELOG<<EOF" >> $GITHUB_ENV
            git log --pretty=format:"* %s (%h)" --no-merges $PREV_TAG..HEAD >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          fi
          
      # Create GitHub Release
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          name: KVM Control v${{ needs.setup.outputs.version }}
          body: |
            # KVM Control v${{ needs.setup.outputs.version }}
            
            ## Changes
            ${{ env.CHANGELOG }}
            
            ## Installation
            - Windows: Download the .exe installer
            - macOS: Download the .dmg file (Note: macOS build is a placeholder for now)
            - Linux: Download the .AppImage file
            
          files: artifacts/**/*
          draft: false
          prerelease: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}